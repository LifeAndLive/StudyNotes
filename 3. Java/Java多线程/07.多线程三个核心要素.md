#### 目录介绍
- 01.线程安全特性
    - 1.1 什么是线程安全
    - 1.2 线程安全级别
- 02.多线程三要素
    - 2.1 三要素分别是啥
    - 2.2 如何理解原子性
    - 2.3 如何理解可见性
    - 2.4 如何理解有序性
    - 2.5 三要素作用
- 03.处理多线程并发
    - 3.1 保证原子性
    - 3.2 保证可见性
    - 3.3 保证有序性
    - 3.4 回答一个问题




### 好消息
- 博客笔记大汇总【16年3月到至今】，包括Java基础及深入知识点，Android技术博客，Python学习笔记等等，还包括平时开发中遇到的bug汇总，当然也在工作之余收集了大量的面试题，长期更新维护并且修正，持续完善……开源的文件是markdown格式的！同时也开源了生活博客，从12年起，积累共计N篇[近100万字，陆续搬到网上]，转载请注明出处，谢谢！
- **链接地址：https://github.com/yangchong211/YCBlogs**
- 如果觉得好，可以star一下，谢谢！当然也欢迎提出建议，万事起于忽微，量变引起质变！






### 01.线程安全特性
#### 1.1 什么是线程安全
- 什么是线程安全
    - 线程安全就是当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
- 并发切入点是什么？
    - 并发分析的切入点分为**两个核心，三大性质**。两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性。




#### 1.2 线程安全级别
- 线程安全也是有几个级别
    - 不可变：
        - 像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用
    - 绝对线程安全
        - 不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet
    - 相对线程安全
        - 相对线程安全也就是我们通常意义上所说的线程安全，像Vector这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99%的情况下都会出现ConcurrentModificationException，也就是fail-fast机制。
    - 线程非安全[技术博客大总结](https://github.com/yangchong211/YCBlogs)
        - ArrayList、LinkedList、HashMap等都是线程非安全的类.




### 02.多线程三要素
#### 2.1 三要素分别是啥
- 三要素分别是：原子性，可见性，有序性



#### 2.2 如何理解原子性
- 如何理解原子性
    - 即一个操作（有可能包含有多个子操作）要么全部执行（生效），要么全部都不执行（都不生效）。
- 举一个例子
    - 关于原子性，一个非常经典的例子就是银行转账问题：比如A和B同时向C转账10万元。如果转账操作不具有原子性，A在向C转账时，读取了C的余额为20万，然后加上转账的10万，计算出此时应该有30万，但还未来及将30万写回C的账户，此时B的转账请求过来了，B发现C的余额为20万，然后将其加10万并写回。然后A的转账操作继续——将30万写回C的余额。这种情况下C的最终余额为30万，而非预期的40万。




#### 2.3 如何理解可见性
- 如何理解可见性
    - 当多个线程并发访问共享变量时，一个线程对共享变量的修改，其它线程能够立即看到。
- 举一个例子
    - CPU从主内存中读数据的效率相对来说不高，现在主流的计算机中，都有几级缓存。每个线程读取共享变量时，都会将该变量加载进其对应CPU的高速缓存里，修改该变量后，CPU会立即更新该缓存，但并不一定会立即将其写回主内存（实际上写回主内存的时间不可预期）。此时其它线程（尤其是不在同一个CPU上执行的线程）访问该变量时，从主内存中读到的就是旧的数据，而非第一个线程更新后的数据。这一点是操作系统或者说是硬件层面的机制，所以很多应用开发人员经常会忽略。




#### 2.4 如何理解有序性
- 如何理解有序性
    - 顺序性指的是，程序执行的顺序按照代码的先后顺序执行。
- 举一个例子
    - 语句应该依次执行，但实际上JVM真正在执行这段代码时，并不保证它们一定完全按照此顺序执行。处理器为了提高程序整体的执行效率，可能会对代码进行优化，其中的一项优化方式就是调整代码顺序，按照更高效的顺序执行代码。CPU不按照我的代码顺序执行代码，那怎么保证得到我们想要的效果呢？实际上，CPU虽然并不保证完全按照代码顺序执行，但它会保证程序最终的执行结果和代码顺序执行时的结果一致。




#### 2.5 三要素作用
- 上面这三个要素主要作用是保障线程安全。保证线程安全可从多线程三特性出发：
    - 原子性（Atomicity）：单个或多个操作是要么全部执行，要么都不执行
        - Lock：保证同时只有一个线程能拿到锁，并执行申请锁和释放锁的代码
        - synchronized：对线程加独占锁，被它修饰的类/方法/变量只允许一个线程访问
    - 可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改
        - volatile：保证新值能立即同步到主内存，且每次使用前立即从主内存刷新；
        - synchronized：在释放锁之前会将工作内存新值更新到主存中
    - 有序性（Ordering）：程序代码按照指令顺序执行
        - volatile： 本身就包含了禁止指令重排序的语义
        - synchronized：保证一个变量在同一个时刻只允许一条线程对其进行lock操作，使得持有同一个锁的两个同步块只能串行地进入



### 03.处理多线程并发
#### 3.1 保证原子性
##### 3.1.1 第一种方式：锁和同步
- 常用的保证Java操作原子性的工具是锁和同步方法（或者同步代码块）。
- 使用锁
    - 可以保证同一时间只有一个线程能拿到锁，也就保证了同一时间只有一个线程能执行申请锁和释放锁之间的代码。
    ```
    public void testLock () {
        lock.lock();
        try{
            int j = i;
            i = j + 1;
        } finally {
            lock.unlock();
        }
    }
    ```
- 同步方法或者同步代码块。
    - 使用非静态同步方法时，锁住的是当前实例；使用静态同步方法时，锁住的是该类的Class对象；使用静态代码块时，锁住的是synchronized关键字后面括号内的对象。下面是同步代码块示例
    ```
    public void testLock () {
        synchronized (MainActivity.class){
            int j = i;
            i = j + 1;
        }
    }
    ```
- 总结
    - 无论使用锁还是synchronized，本质都是一样，通过锁来实现资源的排它性，从而实际目标代码段同一时间只会被一个线程执行，进而保证了目标代码段的原子性。这是一种以牺牲性能为代价的方法。


##### 3.1.2 第二种方式：CAS
- 基础类型变量自增（i++）是一种常被误以为是原子操作而实际不是的操作。
    - Java中提供了对应的原子操作类来实现该操作，并保证原子性，其本质是利用了CPU级别的CAS指令。由于是CPU级别的指令，其开销比需要操作系统参与的锁的开销小。AtomicInteger使用方法如下。
    ```
    AtomicInteger atomicInteger = new AtomicInteger();
    for(int b = 0; b < numThreads; b++) {
        new Thread(() -> {
            for(int a = 0; a < iteration; a++) {
                atomicInteger.incrementAndGet();
            }
        }).start();
    }
    ```


#### 3.2 保证可见性
- Java提供了volatile关键字来保证可见性。
    - 当使用volatile修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。



#### 3.3 保证有序性
- Java中可通过volatile在一定程序上保证顺序性，另外还可以通过synchronized和锁来保证顺序性。
- synchronized和锁保证顺序性的原理和保证原子性一样，都是通过保证同一时间只会有一个线程执行目标代码段来实现的。
- 除了从应用层面保证目标代码段执行的顺序性外，JVM还通过被称为happens-before原则隐式地保证顺序性。两个操作的执行顺序只要可以通过happens-before推导出来，则JVM会保证其顺序性，反之JVM对其顺序性不作任何保证，可对其进行任意必要的重新排序以获取高效率。



#### 3.4 回答一个问题
- **平时项目中使用锁和synchronized比较多，而很少使用volatile，难道就没有保证可见性？**
- 锁可以保证可见性？
    - 锁和synchronized即可以保证原子性，也可以保证可见性。都是通过保证同一时间只有一个线程执行目标代码段来实现的。
- 锁和synchronized即可保证原子性也可保证可见性，为何还需要volatile？
    - synchronized和锁需要通过操作系统来仲裁谁获得锁，开销比较高，而volatile开销小很多。因此在只需要保证可见性的条件下，使用volatile的性能要比使用锁和synchronized高得多。
- 既然锁和synchronized可以保证原子性，为什么还需要AtomicInteger这种的类来保证原子操作？
    - 锁和synchronized需要通过操作系统来仲裁谁获得锁，开销比较高，而AtomicInteger是通过CPU级的CAS操作来保证原子性，开销比较小。所以使用AtomicInteger的目的还是为了提高性能。
- synchronized即可修饰非静态方式，也可修饰静态方法，还可修饰代码块，有何区别
    - synchronized修饰非静态同步方法时，锁住的是当前实例；synchronized修饰静态同步方法时，锁住的是该类的Class对象；synchronized修饰静态代码块时，锁住的是synchronized关键字后面括号内的对象。






