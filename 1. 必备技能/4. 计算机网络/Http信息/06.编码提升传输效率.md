#### 目录介绍
- 01.为何要提高传输效率
- 02.直接传输带来的问题
- 03.报文和实体主体差异
- 04.压缩传输的内容编码
- 05.分割发送的分块传输编码




### 01.为何要提高传输效率


### 02.直接传输带来的问题


### 03.报文和实体主体差异
- 报文（message）
    - 是HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输；
- 实体
    - 作为请求或者响应的有效载荷数据被传输，其内容由实体首部和实体主体组成；
- HTTP报文的主体用于传输请求或响应的实体主体；通常,报文主体等于实体主体.只有当传输中进行编码操作时,实体主体的内容发生变化,才导致它和报文主体产生差异。



### 04.压缩传输的内容编码
- HTTP协议中，可以通过"内容编码"，压缩传输的数据；
    - "内容编码"指明应用在实体内容上的编码格式，并保持实体信息原样压缩；
    - "内容编码"后的实体由客户端接收并负责编码；
- 压缩内容编码图[图片摘自网络]
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-b91c0d578202a9a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- 内容编码详细流程
    - 内容编码和传输编码一般都是配合使用的。我们会先使用内容编码，将内容实体进行压缩，然后再通过传输编码分块发送出去。客户端接收到分块的数据，再将数据进行重新整合，还原成最初的数据。


### 05.分割发送的分块传输编码
- 在HTTP通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。
    - 在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面；
    - 这种把实体主体分块的功能称为分块传输编码；
    - 分块传输编码会将实体主体分成多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用"0(CR+LF)"来标记；
    - 分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体；
- 分割发送的分块传输编码图
    - ![image](https://upload-images.jianshu.io/upload_images/4432347-77670acb5bd15669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
- Transfer-Encoding 
    - 在最新的 HTTP/1.1 协议里，就只有 chunked 这个参数，标识当前为分块编码传输。分块编码传输既然只有一个可选的参数，我们就只需要指定它为 Transfer-Encoding:chunked ，后续我们就可以将内容实体包装一个个块进行传输。
- 分块传输的规则：
    - 1.每个分块包含一个 16 进制的数据长度值和真实数据。
    - 2.数据长度值独占一行，和真实数据通过 CRLF(\r\n) 分割。
    - 3.数据长度值，不计算真实数据末尾的 CRLF，只计算当前传输块的数据长度。
    - 4.最后通过一个数据长度值为 0 的分块，来标记当前内容实体传输结束。
- chunked 的拖挂
    - 使用 chunked 进行分块编码传输的时候，传输结束之后，还有机会在分块报文的末尾，再追加一段数据，此数据称为拖挂（Trailer）。
    - 拖挂的数据，可以是服务端在末尾需要传递的数据，客户端其实是可以忽略并丢弃拖挂的内容的，这就需要双方协商好传输的内容了。
    - 在拖挂中可以包含附带的首部字段，除了 Transfer-Encoding、Trailer 以及 Content-Length 首部之外，其他 HTTP 首部都可以作为拖挂发送。
    - 一般我们会使用拖挂来传递一些在响应报文开始的时候，无法确定的某些值，例如：Content-MD5 首部就是一个常见的在拖挂中追加发送的首部。和长度一样，对于需要分块编码传输的内容实体，在开始响应的时候，我们也很难算出它的 MD5 值。






















